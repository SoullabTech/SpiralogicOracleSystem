<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARIA Protection Monitor - Real-Time Dashboard</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #000000;
            color: #ffffff;
            padding: 20px;
            min-height: 100vh;
        }

        .dashboard {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        h1 {
            color: #ffffff;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 4px;
            padding: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .metric-card:hover {
            transform: translateY(-2px);
            background: #222222;
            border-color: #3a3a3a;
        }

        .metric-card.alert {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 10px 30px rgba(255,0,0,0.3); }
            50% { box-shadow: 0 10px 30px rgba(255,0,0,0.1); }
        }

        .metric-label {
            color: #888888;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 10px;
            font-weight: 400;
        }

        .metric-value {
            font-size: 2.5em;
            font-weight: 200;
            margin-bottom: 10px;
            color: #ffffff;
            letter-spacing: -1px;
        }

        .metric-trend {
            font-size: 0.85em;
            color: #666666;
            font-weight: 300;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            position: absolute;
            top: 20px;
            right: 20px;
            animation: blink 2s infinite;
        }

        .status-green { background: #0088ff; }
        .status-yellow { background: #888888; }
        .status-red { background: #cc0000; }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .chart-container {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 4px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .chart-container h3 {
            color: #ffffff;
            font-weight: 300;
            letter-spacing: 1px;
        }

        .layer-flow {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 4px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .layer-flow h3 {
            color: #ffffff;
            font-weight: 300;
            letter-spacing: 1px;
        }

        .flow-diagram {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 20px 0;
        }

        .flow-node {
            text-align: center;
            flex: 1;
            position: relative;
        }

        .flow-node::after {
            content: '‚Üí';
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 24px;
            color: #999;
        }

        .flow-node:last-child::after {
            display: none;
        }

        .node-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
        }

        .cache-node { background: #0088ff; }
        .protection-node { background: #888888; }
        .verifier-node { background: #0088ff; }
        .output-node { background: #333333; }

        .node-label {
            font-weight: 400;
            margin-bottom: 5px;
            color: #ffffff;
            letter-spacing: 0.5px;
        }

        .node-stats {
            font-size: 0.85em;
            color: #666666;
        }

        .threat-log {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 4px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .threat-log h3 {
            color: #ffffff;
            font-weight: 300;
            letter-spacing: 1px;
        }

        .threat-entry {
            padding: 10px;
            border-left: 2px solid #cc0000;
            background: #0a0a0a;
            margin-bottom: 10px;
            border-radius: 2px;
            color: #ffffff;
        }

        .threat-time {
            color: #999;
            font-size: 0.8em;
        }

        .alert-banner {
            background: #cc0000;
            color: white;
            padding: 15px;
            border-radius: 2px;
            margin-bottom: 20px;
            display: none;
            animation: slideDown 0.3s;
            font-weight: 300;
        }

        .alert-banner.active {
            display: block;
        }

        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .connection-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            padding: 10px 20px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #888888;
            font-size: 0.85em;
        }

        .connection-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #0088ff;
        }

        .connection-indicator.disconnected {
            background: #cc0000;
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <h1>üõ°Ô∏è ARIA Protection Monitor</h1>

        <div id="alertBanner" class="alert-banner">
            <strong>‚ö†Ô∏è ALERT:</strong> <span id="alertMessage"></span>
        </div>

        <!-- Key Metrics Grid -->
        <div class="metrics-grid">
            <div class="metric-card" id="requestCard">
                <div class="status-indicator status-green"></div>
                <div class="metric-label">Total Requests</div>
                <div class="metric-value" id="totalRequests">0</div>
                <div class="metric-trend" id="requestTrend">‚Üë 0/min</div>
            </div>

            <div class="metric-card" id="cacheCard">
                <div class="status-indicator status-green"></div>
                <div class="metric-label">Cache Hit Rate</div>
                <div class="metric-value" id="cacheHitRate">0%</div>
                <div class="metric-trend" id="cacheTrend">Serving fast</div>
            </div>

            <div class="metric-card" id="threatCard">
                <div class="status-indicator status-green"></div>
                <div class="metric-label">Threats Blocked</div>
                <div class="metric-value" id="threatsBlocked">0</div>
                <div class="metric-trend" id="threatTrend">All clear</div>
            </div>

            <div class="metric-card" id="latencyCard">
                <div class="status-indicator status-green"></div>
                <div class="metric-label">Avg Latency</div>
                <div class="metric-value" id="avgLatency">0ms</div>
                <div class="metric-trend" id="latencyTrend">Fast</div>
            </div>
        </div>

        <!-- Layer Flow Visualization -->
        <div class="layer-flow">
            <h3 style="margin-bottom: 20px;">Request Flow Through Layers</h3>
            <div class="flow-diagram">
                <div class="flow-node">
                    <div class="node-icon cache-node">üì¶</div>
                    <div class="node-label">Cache</div>
                    <div class="node-stats">
                        <div id="cacheStats">0 hits</div>
                        <div style="color: #4CAF50;">< 1ms</div>
                    </div>
                </div>

                <div class="flow-node">
                    <div class="node-icon protection-node">üõ°Ô∏è</div>
                    <div class="node-label">Protection</div>
                    <div class="node-stats">
                        <div id="protectionStats">0 checked</div>
                        <div style="color: #FF9800;">~10ms</div>
                    </div>
                </div>

                <div class="flow-node">
                    <div class="node-icon verifier-node">‚úÖ</div>
                    <div class="node-label">Verifier</div>
                    <div class="node-stats">
                        <div id="verifierStats">0 verified</div>
                        <div style="color: #4CAF50;">~200ms</div>
                    </div>
                </div>

                <div class="flow-node">
                    <div class="node-icon output-node">üì§</div>
                    <div class="node-label">Output</div>
                    <div class="node-stats">
                        <div id="outputStats">0 responses</div>
                        <div id="outputMode">Mixed modes</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Charts Row -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <div class="chart-container">
                <h3>Layer Contribution</h3>
                <div id="layerPieChart"></div>
            </div>

            <div class="chart-container">
                <h3>Confidence Distribution</h3>
                <div id="confidenceHistogram"></div>
            </div>
        </div>

        <!-- Attack Patterns Chart -->
        <div class="chart-container">
            <h3>Attack Patterns (Last Hour)</h3>
            <div id="attackTimeline"></div>
        </div>

        <!-- Threat Log -->
        <div class="threat-log">
            <h3 style="margin-bottom: 15px;">Recent Threats</h3>
            <div id="threatLogEntries">
                <div style="color: #999; text-align: center; padding: 20px;">
                    No threats detected yet
                </div>
            </div>
        </div>

        <!-- Connection Status -->
        <div class="connection-status">
            <div class="connection-indicator" id="connectionIndicator"></div>
            <span id="connectionText">Connected</span>
        </div>
    </div>

    <script>
        // Dashboard State
        let metrics = {
            totalRequests: 0,
            cacheHits: 0,
            protectionBlocks: 0,
            verifierCalls: 0,
            threats: [],
            confidenceValues: [],
            requestsPerMinute: [],
            currentAlerts: []
        };

        // Alert Thresholds
        const ALERT_THRESHOLDS = {
            threatRate: 10,        // threats per minute
            latency: 500,          // milliseconds
            cacheHitRate: 0.5,     // minimum acceptable
            errorRate: 0.1         // maximum acceptable
        };

        // Initialize Charts
        function initCharts() {
            // Layer Pie Chart
            Plotly.newPlot('layerPieChart', [{
                values: [1, 1, 1],
                labels: ['Cache Hits', 'Protection Blocks', 'Verifier Calls'],
                type: 'pie',
                marker: {
                    colors: ['#2196F3', '#FF9800', '#4CAF50']
                }
            }], {
                height: 300,
                margin: { t: 20, b: 20, l: 20, r: 20 }
            });

            // Confidence Histogram
            Plotly.newPlot('confidenceHistogram', [{
                x: [],
                type: 'histogram',
                marker: { color: '#9C27B0' }
            }], {
                height: 300,
                margin: { t: 20, b: 20, l: 40, r: 20 },
                xaxis: { title: 'Confidence', range: [0, 1] },
                yaxis: { title: 'Count' }
            });

            // Attack Timeline
            Plotly.newPlot('attackTimeline', [{
                x: [],
                y: [],
                type: 'scatter',
                mode: 'lines+markers',
                line: { color: '#F44336' }
            }], {
                height: 250,
                margin: { t: 20, b: 40, l: 40, r: 20 },
                xaxis: { title: 'Time' },
                yaxis: { title: 'Threats/min' }
            });
        }

        // Update Metrics Display
        function updateMetrics(data) {
            // Update counters
            document.getElementById('totalRequests').textContent = data.totalRequests || 0;
            document.getElementById('cacheHitRate').textContent =
                Math.round((data.cacheHits / Math.max(data.totalRequests, 1)) * 100) + '%';
            document.getElementById('threatsBlocked').textContent = data.protectionBlocks || 0;
            document.getElementById('avgLatency').textContent =
                Math.round(data.averageLatency || 0) + 'ms';

            // Update flow stats
            document.getElementById('cacheStats').textContent = `${data.cacheHits || 0} hits`;
            document.getElementById('protectionStats').textContent =
                `${(data.totalRequests - data.cacheHits) || 0} checked`;
            document.getElementById('verifierStats').textContent = `${data.verifierCalls || 0} verified`;
            document.getElementById('outputStats').textContent = `${data.totalRequests || 0} responses`;

            // Check alerts
            checkAlerts(data);

            // Update charts
            updateCharts(data);
        }

        // Update Charts
        function updateCharts(data) {
            // Update pie chart
            Plotly.update('layerPieChart', {
                values: [[data.cacheHits, data.protectionBlocks, data.verifierCalls]]
            });

            // Update confidence histogram if new data
            if (data.confidenceValues && data.confidenceValues.length > 0) {
                Plotly.update('confidenceHistogram', {
                    x: [data.confidenceValues]
                });
            }

            // Update attack timeline
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            const threatsPerMin = calculateThreatsPerMinute(data.protectionBlocks);

            Plotly.extendTraces('attackTimeline', {
                x: [[timeString]],
                y: [[threatsPerMin]]
            }, [0]);

            // Keep only last 60 points
            if (document.getElementById('attackTimeline').data[0].x.length > 60) {
                Plotly.relayout('attackTimeline', {
                    'xaxis.range': [timeString, timeString]
                });
            }
        }

        // Check Alert Thresholds
        function checkAlerts(data) {
            const alerts = [];

            // Check threat rate
            const threatsPerMin = calculateThreatsPerMinute(data.protectionBlocks);
            if (threatsPerMin > ALERT_THRESHOLDS.threatRate) {
                alerts.push(`High threat rate: ${threatsPerMin} threats/min`);
                setCardAlert('threatCard', true);
            } else {
                setCardAlert('threatCard', false);
            }

            // Check latency
            if (data.averageLatency > ALERT_THRESHOLDS.latency) {
                alerts.push(`High latency: ${Math.round(data.averageLatency)}ms`);
                setCardAlert('latencyCard', true);
            } else {
                setCardAlert('latencyCard', false);
            }

            // Check cache hit rate
            const cacheRate = data.cacheHits / Math.max(data.totalRequests, 1);
            if (cacheRate < ALERT_THRESHOLDS.cacheHitRate && data.totalRequests > 10) {
                alerts.push(`Low cache hit rate: ${Math.round(cacheRate * 100)}%`);
                setCardAlert('cacheCard', true);
            } else {
                setCardAlert('cacheCard', false);
            }

            // Display alerts
            if (alerts.length > 0) {
                showAlert(alerts[0]);
            } else {
                hideAlert();
            }
        }

        // Alert UI Functions
        function setCardAlert(cardId, isAlert) {
            const card = document.getElementById(cardId);
            if (isAlert) {
                card.classList.add('alert');
                card.querySelector('.status-indicator').className = 'status-indicator status-red';
            } else {
                card.classList.remove('alert');
                card.querySelector('.status-indicator').className = 'status-indicator status-green';
            }
        }

        function showAlert(message) {
            const banner = document.getElementById('alertBanner');
            document.getElementById('alertMessage').textContent = message;
            banner.classList.add('active');
        }

        function hideAlert() {
            document.getElementById('alertBanner').classList.remove('active');
        }

        // Add threat to log
        function addThreatToLog(threat) {
            const logContainer = document.getElementById('threatLogEntries');

            // Clear placeholder if first threat
            if (logContainer.children.length === 1 &&
                logContainer.children[0].textContent.includes('No threats')) {
                logContainer.innerHTML = '';
            }

            const entry = document.createElement('div');
            entry.className = 'threat-entry';
            entry.innerHTML = `
                <div><strong>${threat.type}</strong>: ${threat.message}</div>
                <div class="threat-time">${new Date().toLocaleTimeString()}</div>
            `;

            logContainer.insertBefore(entry, logContainer.firstChild);

            // Keep only last 10 entries
            while (logContainer.children.length > 10) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // Helper Functions
        function calculateThreatsPerMinute(totalThreats) {
            // Simple calculation - in production would use sliding window
            return Math.round(totalThreats / Math.max(metrics.totalRequests / 60, 1));
        }

        // WebSocket Connection (or polling simulation)
        function connectToServer() {
            // In production, use WebSocket
            // For now, simulate with polling
            setInterval(() => {
                // Simulate metrics update
                metrics.totalRequests += Math.floor(Math.random() * 5);
                metrics.cacheHits += Math.floor(Math.random() * 4);

                if (Math.random() > 0.9) {
                    metrics.protectionBlocks++;
                    addThreatToLog({
                        type: 'Rapid Fire',
                        message: 'Blocked repeated attempts from user'
                    });
                }

                if (Math.random() > 0.7) {
                    metrics.verifierCalls++;
                }

                metrics.averageLatency = 50 + Math.random() * 100;

                updateMetrics(metrics);
            }, 2000);
        }

        // Initialize Dashboard
        initCharts();
        connectToServer();
    </script>
</body>
</html>