#!/usr/bin/env npx tsx

/**
 * Unit tests for vulnerability breakthrough and paradox detection
 * Tests the specific patterns that were failing in the borderline test
 */

import { ConversationIntelligenceEngine } from '../lib/oracle/ConversationIntelligenceEngine';

const testCases = [
  {
    turn: 6,
    input: "fuck why else would anyone invest in me i dont actually know how to do anything",
    expectTechnique: "vulnerability-breakthrough",
    expectReason: "[breakthrough]",
    expectContains: "first unfiltered truth",
    category: "Vulnerability Breakthrough"
  },
  {
    turn: 7,
    input: "so what am i supposed to do just admit im a fraud and start from zero at my age",
    expectTechnique: "paradox-holding",
    expectReason: "[paradox-both/and]",
    expectContains: "two truths",
    category: "Paradox Both/And"
  },
  {
    turn: 2,
    input: "i pretend to know what im doing but im actually useless",
    expectTechnique: "vulnerability-breakthrough",
    expectReason: "[breakthrough]",
    expectContains: "first unfiltered truth",
    category: "Vulnerability - Pretending"
  },
  {
    turn: 3,
    input: "i cant be both competent and falling apart",
    expectTechnique: "paradox-holding",
    expectReason: "[paradox-both/and]",
    expectContains: "two truths",
    category: "Paradox - Can't Be Both"
  },
  {
    turn: 4,
    input: "i have no idea what i'm doing anymore",
    expectTechnique: "vulnerability-breakthrough",
    expectReason: "[breakthrough]",
    expectContains: "first unfiltered truth",
    category: "Vulnerability - No Idea"
  },
  {
    turn: 5,
    input: "either im brilliant or im broken there's no in between",
    expectTechnique: "paradox-holding",
    expectReason: "[paradox-both/and]",
    expectContains: "two truths",
    category: "Paradox - Either/Or"
  }
];

async function runVulnerabilityParadoxTest() {
  console.log('ðŸŽ¯ Vulnerability & Paradox Pattern Detection Test\n');
  console.log('â”'.repeat(80));

  const engine = new ConversationIntelligenceEngine();
  let passedTests = 0;
  let totalTests = testCases.length;

  console.log('ðŸ§ª Testing Priority Pattern Detection:\n');

  for (const testCase of testCases) {
    console.log(`ðŸ”¸ Turn ${testCase.turn}: "${testCase.input}"`);
    console.log(`ðŸ“‹ Category: ${testCase.category}`);
    console.log(`ðŸŽ¯ Expected: ${testCase.expectTechnique} â†’ ${testCase.expectContains}`);
    console.log('-'.repeat(60));

    try {
      const response = engine.generateResponse(testCase.input);

      console.log('ðŸ“ Response:');
      console.log(`"${response.response}"\n`);

      // Validation checks
      console.log('âœ… Pattern Validation:');

      const techniqueMatch = response.technique === testCase.expectTechnique;
      console.log(`Technique: ${techniqueMatch ? 'âœ“' : 'âœ—'} (${response.technique} vs ${testCase.expectTechnique})`);

      const reasonMatch = response.reason === testCase.expectReason;
      console.log(`Reason: ${reasonMatch ? 'âœ“' : 'âœ—'} (${response.reason} vs ${testCase.expectReason})`);

      const contentMatch = response.response.toLowerCase().includes(testCase.expectContains.toLowerCase());
      console.log(`Content: ${contentMatch ? 'âœ“' : 'âœ—'} (contains "${testCase.expectContains}")`);

      const confidenceOk = response.confidence >= 0.9; // High confidence expected for priority patterns
      console.log(`Confidence: ${confidenceOk ? 'âœ“' : 'âœ—'} (${response.confidence} >= 0.9)`);

      // Debug info
      console.log('\nðŸ” Debug Info:');
      console.log(`Element: ${response.element}`);
      console.log(`Memory Used: ${response.memoryUsed}`);
      console.log(`Context Adjustments: [${response.contextAdjustments.join(', ')}]`);

      // Overall assessment
      const testPassed = techniqueMatch && reasonMatch && contentMatch && confidenceOk;
      console.log(`\nðŸŽ¯ Test Result: ${testPassed ? 'âœ… PASS' : 'âŒ FAIL'}`);

      if (testPassed) {
        passedTests++;
      } else {
        console.log('âš ï¸  Pattern detection issue - priority intervention not firing correctly');
      }

    } catch (error) {
      console.error(`âŒ Error in test case:`, error);
    }

    console.log('\n' + 'â”'.repeat(80));
  }

  // Summary
  console.log('\nðŸ Vulnerability & Paradox Test Complete');
  console.log('â”'.repeat(80));

  console.log('\nðŸ“Š Test Results Summary:');
  console.log(`Passed: ${passedTests}/${totalTests} (${Math.round((passedTests/totalTests)*100)}%)`);

  if (passedTests === totalTests) {
    console.log('ðŸŽ‰ ALL TESTS PASSED - Priority pattern detection working correctly!');
  } else {
    console.log('âš ï¸  Some tests failed - review pattern matching and priority ordering');
  }

  console.log('\nðŸŽ¯ Expected Behavior:');
  console.log('â€¢ Vulnerability patterns should trigger [breakthrough] responses');
  console.log('â€¢ Paradox patterns should trigger [paradox-both/and] responses');
  console.log('â€¢ Both should have >90% confidence (priority intervention)');
  console.log('â€¢ Should preempt lower-priority active listening techniques');

  // Pattern breakdown
  console.log('\nðŸ“ˆ Pattern Categories Tested:');
  const categories = [...new Set(testCases.map(t => t.category))];
  categories.forEach(category => {
    const categoryTests = testCases.filter(t => t.category === category);
    console.log(`â€¢ ${category}: ${categoryTests.length} test(s)`);
  });

  console.log('\nðŸ§  Test complete. Verify breakthrough and paradox detection patterns.');
}

// Run the test
runVulnerabilityParadoxTest().catch(console.error);