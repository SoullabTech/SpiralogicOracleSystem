#!/usr/bin/env npx tsx

/**
 * Unit tests for vulnerability breakthrough and paradox detection
 * Tests the specific patterns that were failing in the borderline test
 */

import { ConversationIntelligenceEngine } from '../lib/oracle/ConversationIntelligenceEngine';

const testCases = [
  {
    turn: 6,
    input: "fuck why else would anyone invest in me i dont actually know how to do anything",
    expectTechnique: "vulnerability-breakthrough",
    expectReason: "[breakthrough]",
    expectContains: "first unfiltered truth",
    category: "Vulnerability Breakthrough"
  },
  {
    turn: 7,
    input: "so what am i supposed to do just admit im a fraud and start from zero at my age",
    expectTechnique: "paradox-holding",
    expectReason: "[paradox-both/and]",
    expectContains: "two truths",
    category: "Paradox Both/And"
  },
  {
    turn: 2,
    input: "i pretend to know what im doing but im actually useless",
    expectTechnique: "vulnerability-breakthrough",
    expectReason: "[breakthrough]",
    expectContains: "first unfiltered truth",
    category: "Vulnerability - Pretending"
  },
  {
    turn: 3,
    input: "i cant be both competent and falling apart",
    expectTechnique: "paradox-holding",
    expectReason: "[paradox-both/and]",
    expectContains: "two truths",
    category: "Paradox - Can't Be Both"
  },
  {
    turn: 4,
    input: "i have no idea what i'm doing anymore",
    expectTechnique: "vulnerability-breakthrough",
    expectReason: "[breakthrough]",
    expectContains: "first unfiltered truth",
    category: "Vulnerability - No Idea"
  },
  {
    turn: 5,
    input: "either im brilliant or im broken there's no in between",
    expectTechnique: "paradox-holding",
    expectReason: "[paradox-both/and]",
    expectContains: "two truths",
    category: "Paradox - Either/Or"
  }
];

async function runVulnerabilityParadoxTest() {
  console.log('🎯 Vulnerability & Paradox Pattern Detection Test\n');
  console.log('━'.repeat(80));

  const engine = new ConversationIntelligenceEngine();
  let passedTests = 0;
  let totalTests = testCases.length;

  console.log('🧪 Testing Priority Pattern Detection:\n');

  for (const testCase of testCases) {
    console.log(`🔸 Turn ${testCase.turn}: "${testCase.input}"`);
    console.log(`📋 Category: ${testCase.category}`);
    console.log(`🎯 Expected: ${testCase.expectTechnique} → ${testCase.expectContains}`);
    console.log('-'.repeat(60));

    try {
      const response = engine.generateResponse(testCase.input);

      console.log('📝 Response:');
      console.log(`"${response.response}"\n`);

      // Validation checks
      console.log('✅ Pattern Validation:');

      const techniqueMatch = response.technique === testCase.expectTechnique;
      console.log(`Technique: ${techniqueMatch ? '✓' : '✗'} (${response.technique} vs ${testCase.expectTechnique})`);

      const reasonMatch = response.reason === testCase.expectReason;
      console.log(`Reason: ${reasonMatch ? '✓' : '✗'} (${response.reason} vs ${testCase.expectReason})`);

      const contentMatch = response.response.toLowerCase().includes(testCase.expectContains.toLowerCase());
      console.log(`Content: ${contentMatch ? '✓' : '✗'} (contains "${testCase.expectContains}")`);

      const confidenceOk = response.confidence >= 0.9; // High confidence expected for priority patterns
      console.log(`Confidence: ${confidenceOk ? '✓' : '✗'} (${response.confidence} >= 0.9)`);

      // Debug info
      console.log('\n🔍 Debug Info:');
      console.log(`Element: ${response.element}`);
      console.log(`Memory Used: ${response.memoryUsed}`);
      console.log(`Context Adjustments: [${response.contextAdjustments.join(', ')}]`);

      // Overall assessment
      const testPassed = techniqueMatch && reasonMatch && contentMatch && confidenceOk;
      console.log(`\n🎯 Test Result: ${testPassed ? '✅ PASS' : '❌ FAIL'}`);

      if (testPassed) {
        passedTests++;
      } else {
        console.log('⚠️  Pattern detection issue - priority intervention not firing correctly');
      }

    } catch (error) {
      console.error(`❌ Error in test case:`, error);
    }

    console.log('\n' + '━'.repeat(80));
  }

  // Summary
  console.log('\n🏁 Vulnerability & Paradox Test Complete');
  console.log('━'.repeat(80));

  console.log('\n📊 Test Results Summary:');
  console.log(`Passed: ${passedTests}/${totalTests} (${Math.round((passedTests/totalTests)*100)}%)`);

  if (passedTests === totalTests) {
    console.log('🎉 ALL TESTS PASSED - Priority pattern detection working correctly!');
  } else {
    console.log('⚠️  Some tests failed - review pattern matching and priority ordering');
  }

  console.log('\n🎯 Expected Behavior:');
  console.log('• Vulnerability patterns should trigger [breakthrough] responses');
  console.log('• Paradox patterns should trigger [paradox-both/and] responses');
  console.log('• Both should have >90% confidence (priority intervention)');
  console.log('• Should preempt lower-priority active listening techniques');

  // Pattern breakdown
  console.log('\n📈 Pattern Categories Tested:');
  const categories = [...new Set(testCases.map(t => t.category))];
  categories.forEach(category => {
    const categoryTests = testCases.filter(t => t.category === category);
    console.log(`• ${category}: ${categoryTests.length} test(s)`);
  });

  console.log('\n🧠 Test complete. Verify breakthrough and paradox detection patterns.');
}

// Run the test
runVulnerabilityParadoxTest().catch(console.error);